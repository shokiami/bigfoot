Project Bigfoot


When we designed this project, one of our main goals was to make this project as expandable as we could. The scope of this project is really big, with the long term goals including integration with a chrome extension and the addition of different aspects of a cabon footprint analysis. To do this, we wanted to incorporate the elements of abstraction we learned in class, and make a way so that new estimation algorithms can be added with very little manipulation of the main source code.

We started of the design process with the Product class. We knew we wanted to have a product class, to keep track of all of the attributes and parameters that would be needed for the estimation. We decided that the product class would have four required attributes, that all products have, which are name, price, weight, and seller. We found all of these attributes are always on online stores, and we thought they were important for our estimation. With the base attributes decided on, we moved onto the expandable section of the Product class, the ProductTraits.

The interface ProductTrait only has one method, an estimate method, that returns a double in kg of CO2. A class that implements the ProductTrait interface represents a section of the carbon footprint of a product. For example, the ProductTraits that we defined are MaterialComposition, Shipping, and Company. These classes all represent their own part of the carbon footprint, like the emissions from gathering raw materials or from shipping. A product class has a variable number of these traits stored in it, and when the method estimate is called, it loops through all of its traits and sums the emissions from all of them. This design means that if we want to add a new trait, the trait can inherit from ProductTrait, and then it is usable on a product, with no modification of the Product class. There are many areas of the carbon footprint we are missing, such as emissions from disposal and typical usage, so this expandability makes it easy for the algorithm to grow and become more accurate.


Going more in depth on how each class works, I will start with the MaterialComposition class. When I created this class, I knew I wanted to have an external file with all of the materials and their carbon footprints. I didn't want to have to load it in every time I constructed a MaterialComposition object. To solve this, I created the MaterialData object, which holds all static data that is constant between products. The MaterialData object contains a list of Material objects, each representing a different type of material. Each material object has a name, category, and the carbon footprint. The materials also have an estimate method, which takes a weight and returns the carbon footprint of that weight of material. Materials can be gotten from the MateriaData object with their name, which searches for a matching material.

In usage, the MaterialData object is created when the program starts, which loads in all of the data. The constructor of a MaterialComposition object includes a referance to the MaterialData object, which lets the MaterialComposition have access to the data. This method has a lot of benefits, other than just the reduced reading and processing. It means that all materials used are the same references, all pointing to the materials in the MaterialData instance. This means materials can be tested for equality and stored in Maps and Sets, without having to worry about duplicate objects.

With all of the data loaded in and ready, the MaterialComposition class is ready to calculate. With all of these helper classes, the MaterialComposition class doesn't actually have a lot to do for calculation. It is constructed with a product reference, a materialdata reference, and a Map of Materials to doubles. The map represents the composition, with each material having a fraction of the product. When estimate is called, the product's weight is multiplied by all of the material's fractions, and estimate is called on each material with their weight. The total emissions is summed up to get the total, which is returned.
